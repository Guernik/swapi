#!/usr/bin/env escript

%% -*- erlang -*-
%%! 


main(Args) ->
  code:add_path("deps/jiffy/_build/default/lib/jiffy/ebin"),
  start_inet_sll(),
  L = get_character(Args),
  io:format("~p~n",[L]).
%%  L = jiffy:decode(<<"{\"foo\": \"bar\"}">>),


start_inet_sll() -> 
  inets:start(),
  ssl:start().


%% request_character/1
%% 
get_character(CharacterName) ->
  {ok, Character} = do_swapi_co_search(people,CharacterName),
  JsonSearchResult = jiffy:decode(Character,[return_maps]),  
  Count = maps:get(<<"count">>,JsonSearchResult),
  treat_result(Count,JsonSearchResult,CharacterName).

treat_result(Count,JsonSearchResult,_CharName) when Count =:= 1 ->
  ResultList = maps:get(<<"results">>,JsonSearchResult),
  hd(ResultList);
  
treat_result(Count,_JsonSearchResult, CharName) when Count > 1 ->
  io:format("More than one posible character for the input ~s~n",[CharName]).
  
    



do_swapi_co_search(people,Who) ->
  EscapedWho = escape_spaces(Who),
  do_http_get_request([swapi_co_base_url(), <<"people/">>, <<"?search=">>, EscapedWho]).

%% More search functions can be added as needed, ie: do_swapi_co_search(films,WhichOne) ...


do_swapi_co_get_all_films() ->
  do_http_get_request([swapi_co_base_url(), <<"films/">>]).


%% Make a syncronous http request and returns the 
%% resulting Body as a binary string.
do_http_get_request(Uri) ->
  Res = httpc:request(get, {Uri, []}, [], []),
    case Res of 
      {ok, {{_HttpVersion,200,_ReasonPhrase}, _Headers, Body}} ->
        {ok, list_to_binary(Body)};
    {error, Reason} -> 
        {error, Reason};
    _Else ->
        {error,<<"Invalid response from internal http client performing request.">>}
  end.
  

swapi_co_base_url() ->
  <<"http://swapi.co/api/">>.



escape_spaces(String) ->
  string:replace(String," ", "%20").

test_json_lib() ->
  jiffy:decode(<<"{\"foo\": \"bar\"}">>).



%%escape_spaces([]) -> [];
%%escape_spaces([H|T]) ->
%%  [escape_spaces(H) | escape_spaces(T) ];

%%escape_spaces(Char) -> 
%%  case Char of 
%%   32 ->
%%  "%20";
%%  _Else ->
%%  Char
%%  end.



deep_get( [], Map ) -> Map;
deep_get( [H|T], Map) ->
  deep_get(T, maps:get(H,Map) ).

console_print(Mesg) ->
  io:format(Mesg++"~n").